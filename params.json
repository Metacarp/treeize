{"name":"Treeize.js","tagline":"Convert row data (in JSON/associative array format) to tree/deep-object structure based on column naming conventions.","body":"# Treeize.js\r\n\r\n[![Build Status via Travis CI](https://travis-ci.org/kwhitley/treeize.svg?branch=feature%2Fmulti-format)](https://travis-ci.org/kwhitley/treeize)\r\n\r\nConverts row data (in JSON/associative array format or flat array format) to object/tree structure based on simple column naming conventions.\r\n\r\n## Installation\r\n\r\n```\r\nnpm install treeize\r\n```\r\n\r\n## Why?\r\n\r\nBecause APIs usually require data in a deep object graph/collection form, but SQL results (especially heavily joined data), excel, csv, and other flat data sources that we're often forced to drive our applications from represent data in a very \"flat\" way.  Treeize takes this flattened data and based on simple column/attribute naming conventions, remaps it into a deep object graph - all without the overhead/hassle of hydrating a traditional ORM.\r\n\r\n#### What it does...\r\n\r\n```js\r\n// Treeize turns flat associative data (as from SQL queries) like this:\r\nvar peopleData = [\r\n  {\r\n    'name': 'John Doe',\r\n    'age': 34,\r\n    'pets:name': 'Rex',\r\n    'pets:type': 'dog',\r\n    'pets:toys:type': 'bone'\r\n  },\r\n  {\r\n    'name': 'John Doe',\r\n    'age': 34,\r\n    'pets:name': 'Rex',\r\n    'pets:type': 'dog',\r\n    'pets:toys:type': 'ball'\r\n  },\r\n  {\r\n    'name': 'Mary Jane',\r\n    'age': 19,\r\n    'pets:name': 'Mittens',\r\n    'pets:type': 'kitten',\r\n    'pets:toys:type': 'yarn'\r\n  },\r\n  {\r\n    'name': 'Mary Jane',\r\n    'age': 19,\r\n    'pets:name': 'Fluffy',\r\n    'pets:type': 'cat'\r\n  }\r\n];\r\n\r\n\r\n// ...or flat array-of-values data (as from CSV/excel) like this:\r\nvar peopleData = [\r\n  ['name', 'age', 'pets:name', 'pets:type', 'pets:toys:type'], // header row\r\n  ['John Doe', 34, 'Rex', 'dog', 'bone'],\r\n  ['John Doe', 34, 'Rex', 'dog', 'ball'],\r\n  ['Mary Jane', 19, 'Mittens', 'kitten', 'yarn'],\r\n  ['Mary Jane', 19, 'Fluffy', 'cat', null]\r\n];\r\n\r\n\r\n// ...via a dead-simple implementation:\r\nvar Treeize   = require('treeize');\r\nvar people    = new Treeize();\r\n\r\npeople.grow(peopleData);\r\n\r\n\r\n// ...into deep API-ready object graphs like this:\r\npeople.getData() == [\r\n  {\r\n    name: 'John Doe',\r\n    age: 34,\r\n    pets: [\r\n      {\r\n        name: 'Rex',\r\n        type: 'dog',\r\n        toys: [\r\n          { type: 'bone' },\r\n          { type: 'ball' }\r\n        ]\r\n      }\r\n    ]\r\n  },\r\n  {\r\n    name: 'Mary Jane',\r\n    age: 19,\r\n    pets: [\r\n      {\r\n        name: 'Mittens',\r\n        type: 'kitten',\r\n        toys: [\r\n          { type: 'yarn' }\r\n        ]\r\n      },\r\n      {\r\n        name: 'Fluffy',\r\n        type: 'cat'\r\n      }\r\n    ]\r\n  }\r\n];\r\n```\r\n\r\n\r\n# API Index\r\n\r\n##### 1. get/set options (optional)\r\n\r\n- [`options([options])`](#options) - getter/setter for options\r\n- [`setOptions(options)`](#setOptions) - merges new `[options]` with existing\r\n- [`resetOptions()`](#resetOptions) - resets options to defaults\r\n\r\n##### 2a. set data signature manually if needed (optional)\r\n\r\n- [`signature([row], [options])`](#signature) - getter/setter for signature definitions\r\n- [`setSignature(row, [options])`](#setSignature) - sets signature using a specific row of data/headers (preserves signature between data sets if uniformity option is enabled)\r\n- [`clearSignature()`](#clearSignature) - clear signature between data sets (only needed when previously defined a uniform signature via `setSignature`)\r\n\r\n##### 2b. grow tree from data set(s)\r\n\r\n- [`grow(data, [options])`](#grow) - grow flat `data`, with optional local `[options]`\r\n\r\n##### 3. retrieve transformed data\r\n\r\n- [`getData()`](#getData) - gets current tree data\r\n\r\n##### * misc/internal methods\r\n\r\n- [`getOptions()`](#getOptions) - returns options\r\n- [`getSignature()`](#getSignature) - returns currently defined signature\r\n- [`getStats()`](#getStats) - returns object with growth statistics\r\n- [`toString()`](#toString) - uses `util` to return data in visually formatted object graph\r\n- [`log(arg1, arg2, arg3)`](#log) - console.log output of `arg1..n` when `log` option is set to `true`\r\n\r\n# API\r\n\r\n### .options([options])<a name=\"options\" />\r\n\r\n[Getter](#getOptions)/[Setter](#setOptions) for options.  If options object is passed, this is identical to [.setOptions(options)](#setOptions) and returns self (chainable).  If no options are passed, this is identical to [.getOptions()](#getOptions) and returns current options as object.\r\n\r\n\r\n### .setOptions(options)<a name=\"setOptions\" />\r\n\r\nSets options globally for the Treeize instance.  This is an alias for `.options(options)`. Default options are as follows:\r\n\r\n```js\r\n{\r\n  input: {\r\n    delimiter:          ':',    // delimiter between path segments, defaults to ':'\r\n    detectCollections:  true,   // when true, plural path segments become collections\r\n    uniformRows:        false,  // set to true if each row has identical signatures\r\n  },\r\n  output: {\r\n    prune:              true,   // remove blank/null values and empty nodes\r\n    objectOverwrite:    true,   // incoming objects will overwrite placeholder ids\r\n    resultsAsObject:    false,  // root structure defaults to array (instead of object)\r\n  },\r\n  log:                  false,  // enable logging\r\n}\r\n```\r\n\r\nFor example, to change the delimiter and enable output logging, you would use the following:\r\n\r\n```js\r\n.setOptions({ log: true, input: { delimiter: '|' }});\r\n```\r\n\r\n#### Available Options\r\n\r\n`input.delimiter`<a name=\"optionsInputDelimiter\" />\r\nThis sets the delimiter to be used between path segments (e.g. the \":\" in \"children:mother:name\").\r\n[View test example](https://github.com/kwhitley/treeize/blob/feature/multi-format/test/test.js#L51-58)\r\n\r\n`input.detectCollections`<a name=\"optionsInputDetectCollections\" />\r\nEnables/disables the default behavior of turning plural path segments (e.g. \"subjects\" vs. \"subject\") into collections instead of object paths.  **Note:** In order to properly merge multiple rows into the same collection item, the collection must have a base-level attribute(s) acting as a signature.\r\n[View test example (enabled)](https://github.com/kwhitley/treeize/blob/feature/multi-format/test/test.js#L79-86) | [or (disabled)](https://github.com/kwhitley/treeize/blob/feature/multi-format/test/test.js#L92-99)\r\n\r\n`input.uniformRows`<a name=\"optionsInputUniformRows\" />\r\nBy default row uniformity is disabled to allow the most flexible data merging.  This means each and every row of data that is processed (unless flat array-of-array data) will be analyzed and mapped individually into the final structure.  If your data rows have uniform attributes/columns, disable this for a performance increase.\r\n\r\n`output.prune`<a name=\"optionsOutputPrune\" />\r\nRemoves blank/empty nodes in the structure.  This is enabled by default to prevent sparse data sets from injecting blanks and nulls everywhere in your final output.  If nulls are important to preserve, disable this.\r\n[View test example](https://github.com/kwhitley/treeize/blob/feature/multi-format/test/test.js#L207-240)\r\n\r\n`output.objectOverwrite`<a name=\"optionsOutputObjectOverwrite\" />\r\nTo allow for merging objects directly onto existing placeholder values (e.g. foreign key ids), this is enabled by default.\r\n[View test example](https://github.com/kwhitley/treeize/blob/feature/multi-format/test/test.js#L159-203)\r\n\r\n`output.resultsAsObject`<a name=\"optionsOutputResultsAsObject\" />\r\nThis creates a single root object (instead of the default array of objects).\r\n[View test example](https://github.com/kwhitley/treeize/blob/feature/multi-format/test/test.js#L245-278)\r\n\r\n`log`<a name=\"optionsLog\" />\r\nSetting to true enables traversal information to be logged to console during growth process.\r\n\r\n\r\n### .getOptions()<a name=\"getOptions\" />\r\n\r\nReturns the current global options (as object).\r\n[View example format](#setOptions)\r\n\r\n\r\n### .resetOptions(options)<a name=\"resetOptions\" />\r\n\r\nResets all global options to [original defaults](#setOptions) and returns self (chainable).\r\n\r\n### .signature([row], [options])<a name=\"signature\" />\r\n\r\n[Getter](#getSignature)/[Setter](#setSignature) for row signatures.  If options object is passed, this is identical to [.setSignature(options)](#setSignature) and returns self (chainable).  If no options are passed, this is identical to [.getSignature()](#getSignature) and returns currently defined signature as object.\r\n\r\n\r\n### .setSignature(row, [options])<a name=\"setSignature\" />\r\n\r\nManually defines the signature for upcoming data sets from argument `row`, with optional `options`.  The row may be either in object (key/value) form or flat array form (array of paths). This method is only required if sharing a single signature across multiple data sources (when merging homogeneous data sets), or when the data itself has no header information (for instance, with bulk flat array-of-values data).  Returns self (chainable).\r\n\r\n```js\r\n// May be set from a single row of associative data\r\n.setSignature({\r\n  'id': 1,\r\n  'name:first': 'Kevin',\r\n  'name:last': 'Whitley',\r\n  'hobbies:name': 'photography'\r\n  'hobbies:years': 12\r\n})\r\n\r\n// Or from header row of flat array data\r\n.setSignature(['id', 'name:first', 'name:last', 'hobbies:name', 'hobbies:years'])\r\n```\r\n\r\n### .getSignature()<a name=\"getSignature\" />\r\n\r\nReturns currently defined signature. _For internal use only._\r\n\r\n### .clearSignature()<a name=\"clearSignature\" />\r\n\r\nClears currently-defined signature if previously set via [`setSignature(row)`](#setSignature), and returns self (chainable).  This is only required between data sets if signature auto-detection should be re-enabled.  It is unlikely that you will need to use this.\r\n\r\n### .getData()<a name=\"getData\" />\r\n\r\nReturns current data tree.\r\n\r\n```js\r\nvar tree = new Treeize();\r\n\r\ntree.grow([\r\n  { 'foo': 'bar', 'logs:a': 1 },\r\n  { 'foo': 'bar', 'logs:a': 2 },\r\n  { 'foo': 'baz', 'logs:a': 3 },\r\n]);\r\n\r\nconsole.log(tree.getData());\r\n\r\n/*\r\n[\r\n  { foo: 'bar', logs: [{ a: 1 }, { a: 2 }] },\r\n  { foo: 'baz', logs: [{ a: 3 }]}\r\n]\r\n*/\r\n```\r\n\r\n### .getStats()<a name=\"getStats\" />\r\n\r\nReturns current growth statistics (e.g. number of sources process, number of rows, etc). _Output and format subject to change - use at your own risk._\r\n\r\n### .toString()<a name=\"toString\" />\r\n\r\nTypecasting a treeize instance to String or manually calling `.toString()` on it will output it visually using the `util` library from node.js.\r\n\r\n```js\r\nvar tree = new Treeize();\r\n\r\ntree.grow(data);\r\n\r\n// use automatic typecasting to trigger\r\nconsole.log(tree + '');\r\n\r\n// or call manually\r\nconsole.log(tree.toString());\r\n```\r\n\r\n### .log(arg1, arg2, ...)<a name=\"log\" />\r\n\r\nEquivalent to `console.log(arg1, arg2, ...)` when the `log` option is set to `true`.  Useful for debugging messages or visual output that you can toggle from a single source.\r\n\r\n```js\r\nvar tree = new Treeize();\r\n\r\ntree.log('my message');\r\n// 'my message' will NOT be written to the console\r\n\r\ntree\r\n  .setOptions({ log: true })\r\n  .log('my message')\r\n;\r\n// 'my message' WILL be written to the console\r\n```\r\n\r\n---\r\n\r\n### .grow(data, [options])<a name=\"grow\" />\r\n\r\nThe `grow(data, [options])` method provides the core functionality of Treeize.  This method expands flat data (of one or more sources) into the final deep tree output.  Each attribute path is analyzed for injection into the final object graph.\r\n\r\n#### Path Naming\r\n\r\nEach column/attribute of each row will dictate its own destination path\r\nusing the following format:\r\n\r\n```js\r\n{\r\n  'path1:path2:pathX:attributeName': [value]\r\n}\r\n```\r\n\r\nEach \"path\" (up to n-levels deep) is optional and represents a single object node if the word is singular, or a collection if the word is plural (with optional +/- override modifiers).  For example, a \"favoriteMovie:name\" path will add a \"favoriteMovie\" object to its path - where \"favoriteMovies:name\" would add a collection of movies (complete with a first entry) instead.  For root nodes, include only the attribute name without any preceding paths.  If you were creating a final output of a book collection for instance, the title of the book would likely be pathless as you would want the value on the high-level `books` collection.\r\n\r\nIt's important to note that each row will create or find its path within the newly transformed output being created.  Your flat feed may have mass-duplication, but the results will not.\r\n\r\n##### Merging Multiple Data Sources\r\n\r\nTreeize was designed to merge from multiple data sources of both attribute-value and array-of-value format (as long as signatures are provided in some manner), including ones with varying signatures.\r\n\r\n```js\r\nvar Treeize         = require('treeize');\r\nvar arrayOfObjects  = require('somesource1.js');\r\nvar arrayOfValues   = require('somesource2.js');\r\n\r\nvar tree = new Treeize();\r\n\r\ntree\r\n  .grow(arrayOfObjects)\r\n  .grow(arrayOfValues) // assumes header row as first row\r\n;\r\n\r\n// tree.getData() == final merged results\r\n```\r\n\r\n##### How to manually override the default pluralization scheme for collection-detection\r\n\r\nIn the rare (but possible) case that plural/singular node names are not enough to properly detect collections, you may add specific overrides to the node name, using the `+` (for collections) and `-` (for singular objects) indicators.\r\n\r\n```js\r\n{\r\n  'name':                 'Bird',\r\n  'attributes:legs':      2,\r\n  'attributes:hasWings':  true\r\n}\r\n\r\n// would naturally return\r\n\r\n[\r\n  {\r\n    name: 'Bird',\r\n    attributes: [\r\n      {\r\n        legs: 2,\r\n        hasWings: true\r\n      }\r\n    ]\r\n  }\r\n]\r\n\r\n// to tell treeize that the node (detected as a plural collection)\r\n// is NOT a collection, add a - to the path\r\n\r\n{\r\n  'name':                 'Bird',\r\n  'attributes-:legs':      2,\r\n  'attributes-:hasWings':  true\r\n}\r\n\r\n// results in\r\n\r\n[\r\n  {\r\n    name: 'Bird',\r\n    attributes: {\r\n      legs: 2,\r\n      hasWings: true\r\n    }\r\n  }\r\n]\r\n\r\n// conversely, add a + to a path to force it into a collection\r\n\r\n```\r\n\r\n##### Specifying Your Own Key/Blueprint For Collections\r\n\r\nBy default, all known attributes of a collection node level define a \"blueprint\" by which to match future rows.  For example, in a collection of people, if both `name` and `age` attributes are defined within each row, future rows will require both the `name` and `age` values to match for the additional information to be merged into that record.  To override this default behavior and specify your own criteria, simply _mark each required attribute with a leading or tailing `*` modifier._\r\n\r\n```js\r\n[\r\n  {\r\n    'date': '1/1/2014',\r\n    'temperatureF': 90,\r\n    'temperatureC': 32\r\n  },\r\n  {\r\n    'date': '1/1/2014',\r\n    'humidity': .1\r\n  }\r\n]\r\n\r\n// ...would normally grow into:\r\n[\r\n  {\r\n    date: '1/1/2014',\r\n    temperatureF: 90,\r\n    temperatureC: 32\r\n  },\r\n  {\r\n    date: '1/1/2014',\r\n    humidity: 0.1\r\n  }\r\n]\r\n\r\n// ...but by specifying only the \"date\" attribute as the blueprint/key\r\n[\r\n  {\r\n    'date*': '1/1/2014',\r\n    'temperatureF': 90,\r\n    'temperatureC': 32\r\n  },\r\n  {\r\n    'date*': '1/1/2014',\r\n    'humidity': .1\r\n  }\r\n]\r\n\r\n// ...the data merges appropriately\r\n[\r\n  {\r\n    date: '1/1/2014',\r\n    temperatureF: 90,\r\n    temperatureC: 32,\r\n    humidity: 0.1\r\n  }\r\n]\r\n```\r\n\r\n### Notes\r\n\r\n- Each attribute name of the flat data must consist of the full path to its node & attribute, seperated by the delimiter.  `id` suggests an `id` attribute on a root element, whereas `name:first` implies a `first` attribute on a `name` object within a root element.\r\n- To imply a collection in the path/attribute-name, use a plural name (e.g. \"subjects\" instead of \"subject\").  Otherwise, use a singular name for a singular object.\r\n- Use a `:` delimiter (default) to seperate path segments.  To change this, modify the [`input.delimiter`](#optionsInputDelimiter) option.\r\n\r\n---\r\n\r\n# Examples\r\n\r\nIn this short series of examples, we'll take a standard \"join dump\", originally keyed\r\n(via attribute names) to organize by movie - and demonstrate how other organizations can\r\nbe easily derived from the same original feed... by simply modifying the column/attribute\r\nnames in the output.\r\n\r\n#### Example 1\r\n\r\nIn this example, we'll take our dump (as if from a CSV or SQL result) - and name the keys to\r\ngroup by movies (as if for an `/api/movies`).\r\n\r\n```js\r\nvar movieDump = [\r\n  {\r\n    'title':             'The Prestige',\r\n    'director':          'Christopher Nolan',\r\n    'actors:name':       'Christian Bale',\r\n    'actors:as':         'Alfred Borden'\r\n  },\r\n  {\r\n    'title':             'The Prestige',\r\n    'director':          'Christopher Nolan',\r\n    'actors:name':       'Hugh Jackman',\r\n    'actors:as':         'Robert Angier'\r\n  },\r\n  {\r\n    'title':             'The Dark Knight Rises',\r\n    'director':          'Christopher Nolan',\r\n    'actors:name':       'Christian Bale',\r\n    'actors:as':         'Bruce Wayne'\r\n  },\r\n  {\r\n    'title':             'The Departed',\r\n    'director':          'Martin Scorsese',\r\n    'actors:name':       'Leonardo DiCaprio',\r\n    'actors:as':         'Billy'\r\n  },\r\n  {\r\n    'title':             'The Departed',\r\n    'director':          'Martin Scorsese',\r\n    'actors:name':       'Matt Damon',\r\n    'actors:as':         'Colin Sullivan'\r\n  }\r\n];\r\n\r\nvar Treeize = require('treeize');\r\nvar movies  = new Treeize();\r\n\r\nmovies.grow(movieDump);\r\n\r\n/*\r\n\r\n  'movies.getData()' now results in the following:\r\n\r\n  [\r\n    {\r\n      'director': 'Christopher Nolan',\r\n      'title': 'The Prestige',\r\n      'actors': [\r\n        {\r\n          'as': 'Alfred Borden',\r\n          'name': 'Christian Bale'\r\n        },\r\n        {\r\n          'as': 'Robert Angier',\r\n          'name': 'Hugh Jackman'\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      'director': 'Christopher Nolan',\r\n      'title': 'The Dark Knight Rises',\r\n      'actors': [\r\n        {\r\n          'as': 'Bruce Wayne',\r\n          'name': 'Christian Bale'\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      'director': 'Martin Scorsese',\r\n      'title': 'The Departed',\r\n      'actors': [\r\n        {\r\n          'as': 'Billy',\r\n          'name': 'Leonardo DiCaprio'\r\n        },\r\n        {\r\n          'as': 'Colin Sullivan',\r\n          'name': 'Matt Damon'\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n\r\n*/\r\n```\r\n\r\n#### Example 2\r\n\r\nTaking the same feed, but modifying the target paths through the attribute/column\r\nnames we can completely transform the data (as you would for another API endpoint,\r\nfor example).  This time we'll organize the data by actors, as you would for\r\nand endpoint like `/api/actors`.\r\n\r\nNotice the feed is left unchanged - only the attribute names have been modified to\r\ndefine their new target path.  In this case, by changing the base node to the actor\r\nname (instead of the movie name), we group everything by actor at a high level.\r\n\r\n```js\r\nvar moviesDump = [\r\n  {\r\n    'movies:title':     'The Prestige',\r\n    'movies:director':  'Christopher Nolan',\r\n    'name':             'Christian Bale',\r\n    'movies:as':        'Alfred Borden'\r\n  },\r\n  {\r\n    'movies:title':     'The Prestige',\r\n    'movies:director':  'Christopher Nolan',\r\n    'name':             'Hugh Jackman',\r\n    'movies:as':        'Robert Angier'\r\n  },\r\n  {\r\n    'movies:title':     'The Dark Knight Rises',\r\n    'movies:director':  'Christopher Nolan',\r\n    'name':             'Christian Bale',\r\n    'movies:as':        'Bruce Wayne'\r\n  },\r\n  {\r\n    'movies:title':     'The Departed',\r\n    'movies:director':  'Martin Scorsese',\r\n    'name':             'Leonardo DiCaprio',\r\n    'movies:as':        'Billy'\r\n  },\r\n  {\r\n    'movies:title':     'The Departed',\r\n    'movies:director':  'Martin Scorsese',\r\n    'name':             'Matt Damon',\r\n    'movies:as':        'Colin Sullivan'\r\n  }\r\n];\r\n\r\nvar Treeize = require('treeize');\r\nvar actors  = new Treeize();\r\n\r\nactors.grow(movieDump);\r\n\r\n/*\r\n\r\n  'actors.getData()' now results in the following:\r\n\r\n  [\r\n    {\r\n      'name': 'Christian Bale',\r\n      'movies': [\r\n        {\r\n          'as': 'Alfred Borden',\r\n          'director': 'Christopher Nolan',\r\n          'title': 'The Prestige'\r\n        },\r\n        {\r\n          'as': 'Bruce Wayne',\r\n          'director': 'Christopher Nolan',\r\n          'title': 'The Dark Knight Rises'\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      'name': 'Hugh Jackman',\r\n      'movies': [\r\n        {\r\n          'as': 'Robert Angier',\r\n          'director': 'Christopher Nolan',\r\n          'title': 'The Prestige'\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      'name': 'Leonardo DiCaprio',\r\n      'movies': [\r\n        {\r\n          'as': 'Billy',\r\n          'director': 'Martin Scorsese',\r\n          'title': 'The Departed'\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      'name': 'Matt Damon',\r\n      'movies': [\r\n        {\r\n          'as': 'Colin Sullivan',\r\n          'director': 'Martin Scorsese',\r\n          'title': 'The Departed'\r\n        }\r\n      ]\r\n    }\r\n  ]\r\n\r\n*/\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}